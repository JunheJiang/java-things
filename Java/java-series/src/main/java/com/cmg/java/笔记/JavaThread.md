####线程状态
- 初始化状态 new 继承Thread 或实现Runnable Callable接口一个线程
- 线程开始进入运行与就绪状态、由操作系统调度 yield 到就绪 run到 运行
- 等待/超时等待状态、当前线程sleep 线程join 对象wait LockSupport.parkUntil parkNanos
- 唤醒进入运行与就绪状态、notify notifyAll LockSupport.unPark(thread)
- 阻塞 获取到锁则运行 未获取到锁阻塞

####线程安全
- 可见性、原子性、有序性 线程安全bug源头
- 互斥锁解决原子性 同一时间只能有一个线程执行、内存屏障解决可见性 volatile禁用cpu缓存 1.5后对volatile语义进行增强
  HB原则、按需禁用缓存以及编译优化 final
- HB原则：前一个操作的结果对后续操作是可见的、程序性规则、对volatile变量写操作HB后续对这个volatile读操作、传递性、线程join start 管程的锁先释放后加锁
- 锁保护资源 有关联关系的资源 正确的使用锁 转账问题 Account.class A-B C-D 串行性能无法接受  账本临界资源 细粒度锁锁定范围小 可以提高并行度
- 死锁问题 一组相互竞争资源的线程因相互等待而导致一直阻塞的现象
  解决方法：重启应用、规避预防死锁 打破以下其中一个条件：互斥(无法破坏) 
  占有且等待(一次性申请 临界资源)： 账本管理员 同时申请和释放资源
  不可抢占(申请不到就释放):  synchronized做不到 申请不到会阻塞 Lock 获取锁
  循环等待(按序申请): 先锁定序号小的账户 在锁定序号大的账户
- 共享数据: 多个线程同时读写同一数据  
  数据竞争: 多个线程操作同一数据
  竞态条件: 程序的执行结果依赖线程执行的顺序 超额转出情况 
  if(状态变量 满足 执行条件){
  执行操作
  }
  互斥技术解决这个问题 
  活锁:没有阻塞 还行执行不下去 尝试等待一个随机时间 分布式一致性Raft算法
  饥饿:无法访问所需资源无法 资源充足 公平分配资源
  
####锁性能
- 无锁算法与数据结构 TLS CopyOnWrite 乐观锁 原子类 disruptor无锁队列
- 减少锁持有时间 分段锁技术 读写锁
- 指标数据：吞吐量：单位时间能处理的请求数量
  延迟：从发出请求到收到响应的时间
  并发量：能同时处理请求的数量 
  
####线程实践
- 多少线程合适
- 并发工具类
- 并发容器
- 异步编程
- 并发设计模式
- 开源并发设计思想
  






